\section{Jednorázové a fail-stop podpisové schémy}

Jednorázové podpisové schémy, ako už ich názov napovedá, slúžia na
podpísanie práve jednej správy. Ich bezpečnosť je v prípade viacnásobného
podpisovania ohrozená. Načo sú nám teda takéto podpisové schémy? Zatiaľ to
vyzerá tak, že sú ia menej výhodné. Existujú však dôvody, prečo sa zaoberať
aj takýmito zjavne ``okrátenými'' podpisovými schémami.

Ich hlavná výhoda bude spočívať v jednoduchších predpokladoch pri dôkaze
bezpečnosti. Kým pri bežných podpisových schémach sme stavali na
tažkosti istých matematických problémov (RSA, dlog, Diffie-Hellman),
pri jednorázových schémach nám bude stačiť napríklad jednosmernosť
hashovacej funkcie.\footnote{Už aj toto je pomerne náročný predpoklad,
    keďže nevieme povedať veľa o existencii one-way funkcií}
Druhou výhodou môže byť rýchlosť - zrejme je jednoduchšie hashovať hodnoty
ako napríklad umocňovať.
Treťou výhodou (i keď skôr teoretickou) je možnosť odolať kvantovým
výpočtom - pre väčsinu používaných ťažkých problémov sú známe kvantové
algoritmy, ktoré ich efektívne počítajú. Pre invertovanie hashovacích
funkcií ale takéto algoritmy nie sú známe.

Otázka teda môže znieť, že či jednorázovosť je až taká obmedzujúca
vlastnosť. Môžeme napríklad uvažovať komunikáciu s bankou a podpisovanie
prevodných príkazov. Je jednoducho predstaviteľné, že povedzme za mesiac
bežný človek nespraví viac ako povedzme 5 príkazov. Preto môžeme použiť
niečo ako pohľad z opačnej strany - namiesto toho, aby sme navrhovali
podpisové schémy na polynomiálny počet podpísaných správ,
môžeme sa snažiť navrhnúť schémy na jednorázové podpisy a tie potom
rozšíriť nejakým spôsobom pre viac správ.

Jednorázovú podpisovou schému formálne definujeme veľmi podobne ako bežné
podpisové schémy

\begin{definicia}[Jednorázová podpisová schéma]
    je trojica algoritmov 
    $\langle Gen, Sign_{sk}, Verify_{pk} \rangle$ kde
    $Gen(1^k) \implies \langle pk, sk \rangle$ je generátor kľúčov,
    $Sign_{sk}(m) \implies \sigma$ je podpisovací algoritmus a
    $Verify_{pk}(m,\sigma) \implies \{0,1\}$ je overovací algoritmus.
\end{definicia}

Pojem bezpečnosti takejto schémy si upravíme na jednu správu.
\begin{definicia}[Bezpečnosť]
    Uvažujme útočníka ako PPT algoritmus, ktorý má navyše k dispozícii
    orákulum $Sig_{sk}$. Útočník sa môže raz opýtať orákula na podpis
    $\sigma$ správy $m$ a jeho cieľom je zostrojiť
    správu $m' \ne m$ a k nej platný podpis $\sigma'$.
    Budeme hovoriť, že schéma je bezpečná ak pravdepodobnosť,
    že ľubovoľný útočník uspeje (t.j. nájde $(m',\sigma')$), je zanedbateľná.
\end{definicia}

\subsection{Lamportova schéma}

Uvažujme, že máme funkciu $f: X \rightarrow Y$, ktorá je jednosmerná.
Budeme podpisovať správy $m$ fixnej veľkosti $|m|=n$. Toto samo o sebe nie
je žiadny problém, ak uvážime, že budeme podpisovať len hash správy, ktorý je
fixnej veľkosti.

Generovanie kľúča bude vyzerať nasledovne:
%%% {{{ proc GenLamport
\begin{procedure}
    \caption{GenLamport($n$)}
    \For{$i:=1$ \KwTo $n$}{
        $x_{i,0} \inr X$\;
        $x_{i,1} \inr X$\;
        $y_{i,0} \assign f(x_{i,0})$\;
        $y_{i,1} \assign f(x_{i,1})$\;
    }
    \Return $sk=(x_{1,0},x_{1,1},\ldots,x_{n,0},x_{n,1}),\quad
             pk=(y_{1,0},y_{1,1},\ldots,y_{n,0},y_{n,1})$\;
\end{procedure}
%%% }}}

Čitateľ už môže tušiť, ako budeme podpisovať správu - jednoducho postupne
podpíšeme všetyk jej bity tým, že zverejníme príslušnú časť súkromného
kľúča.

%%% {{{ SignLamport
\begin{procedure}
    \caption{SignLamport($m$)}
    \For{$i:=1$ \KwTo $n$}{
        $\sigma_i \assign f(x_{i, m_i})$\;
    }
    \Return $\sigma = (\sigma_1, \ldots, \sigma_n)$
\end{procedure}
%%% }}}

Overovanie spočíva v overení každého podpísaného bitu správy.

\begin{procedure}
    \caption{VerifyLamport($m, \sigma$)}
    \For{$i:=1$ \KwTo $n$}{
        \If{$f(x_{i, m_i}) \ne y_{i, m_i}$}{
            \Return reject\;
        }
    }
    \Return accept\;
\end{procedure}

Bezpečnosť schémy je založená na nasledujúcom pozorovaní:
Aby bol útočník k správe $m$ a jej podpisu $\sigma$ vygenerovať
falošnú správu $m' \ne m$ a jej podpis $\sigma'$, musel by byť schopný
vygenerovať $x_{i,b}$ pre nejakú novú dvojicu $(i,b)$.
To ale znamená invertovať niektorú hodnotu $y_{i,b}$ z verejnej
funkcie, predpokladáme, že je možné iba so zanedbateľnou
pravdepodobnosťou.

Na druhej strane, schéma je evidentne jednorázová.
Až na špeciálny prípad, keď sú podpísané dve správy $m_1,m_2$ líšiace
sa v práve jednom bite (vtedy si útočník nepomôže), vieme kombinovať
jednotlivé bity podpisov a podpísať inú správu. V prípade, že
podpisujeme hash hodnotu, je navyše očakávané, že správy sa budú líšiť
na zhruba polovici bitov.

Uvažujme teraz praktické aspekty používania takejto schémy. Podpisujme
hash, napríklad výstup z funkcie SHA-256. Ďalej predpokladajme, že
$|X|=|Y|=256 \unit{bit}$. Potom dostávame pre súkromný kľúč veľkosť
$|sk|=2*256*256 bit =16 \unit{kB}$. Verejný kľúč je rovnako dlhý, čiže
$|pk|=16 \unit{kB}$ a podpis má polovičnú dĺžku kľúčov - $|\sigma|=8
\unit{kB}$.
V porovnaní napríklad s RSA je to výrazne horšie. Bolo by teda dobré
nejakým spôsobom skrátiť kľúče.

Skrátenie súkromného kľúča: Namiesto celého kľúča $(x_{1,0}, x_{1,1},
\ldots x_{n,1})$ si budeme pamätať iba náhodné $x \inr X$ - seed pre
pseudonáhodý generátor, ktorý postupne vygeneruje dané hodnoty
$x_{i,b}$. Problém v tomto prípade je ďalší predpoklad - bezpečnost
pseudonáhodného generátora (t.j. že z niektorých hodnôt postupnosti
$x_{1,0}, \ldots, x_{n,1}$ nevieme efektívne vypočítať žiadnu ďalšiu -
to by bolo ekvivalentné zlomeniu podpisovej schémy).

Skrátenie verejného kľúča: Namiesto celého kľúča zverejníme iba hash
$y=H(y_{1,0},y_{1,1},\ldots,y_{n,1})$. Tým pádom ale pri podpisovaní
musíme uviesť aj všetky hodnoty $y$, aby si to overovateľ mohol
overiť. Po chvíli zamyslenia sa ale môžeme pozorovať, že na overenie
stačí poslať tie hodnoty $y_{i,b}$, ktoré si overovateľ nemôže
spočítať. Tieto sú presne negácie bitov správy a teda nám stačí poslať
iba polovicu hodnôt $y_{i,b}$. Podpis sa nám tým predĺži na $16
\unit{kB}$.

\subsubsection{Merkleho konštrukcia}
Ďalši nezávislú možnosť ako skrátiť dĺžku postupnosti vymyslel
Merkle. Hlavnou pointou bude pridať akúsi formu checksumu - počtu
nulových bitov správy. Potom budeme pri podpisovaní podpisovať iba
jednotkové bity, čím ušetríme v priemernom prípade takmer polovicu bitov
(čiže v našom prípade $|\sigma| \approx 4 \unit{kB}$).

Presnejšie, majme správu dĺžky $l$. K nej pridáme checksum dĺžky
$\lceil \log l \rceil$ a na výsledok dĺžky $n=l+\lceil \log l \rceil$
použijeme podpis, kde podpíšeme iba jednotkové bity.

V prvom rade by sme mali ukázať, že takáto zmena nepokazí bezpečnosť
schémy. Majme preto známu správu $m$ s podpisom $\sigma$ a
predpokladajme, že sa útočník snaží vyrobiť $m'$.
Ak existuje bit $i$, $m_i=0$ a platilo by $m'_i=1$, tak sa dostávame
do známej situácie, kedy útočník musí vyrobiť platný vzor pre $y_{i,1}$.
Ošemetná situácia ale nastáva, ak máme bit $m_i=1$ a útočník ho zmení
na nulu. V tomto prípade totiž nemusí nič podvrhnúť, lebo pre nulový
bit nemusí nič uviesť. Zachráni nás však checksum - totiž, ak zmenšíme
celkový počet jednotiek v správe (a to jediné nám ostáva, ak nemáme
nablyšťanú guľu na lámanie one-way funkcie), vznikne nám aspoň jedna
jednotka na doteraz neodhalenom mieste - nie je totiž možné, aby sme
po pričítaní čísla k checksume dostali checksumu pozostávajúci iba zo
známych bitov - to by znamenalo, že daná checksuma používa iba
niektoré jednotky z pôvodnej, lenže to je v spore s tým, že je
väčšia). Preto aj v tomto prípade musí útočník úspešne nájsť vzor
jednosmernej fukncie a schéma ostáva naďalej bezpečná.

Ďalšou príjemnou vlastnosťou tejto úpravy je automatické zmenšenie
súkromného a verejného kľúča na polovicu - vôbec nepotrebujeme
generovať $x_{i,0}$ a $y_{i,0}$.

\subsection{Merkleho stromy}
\subsection{Stanekova schéma}
\subsection{Fail/stop podpisové schémy}

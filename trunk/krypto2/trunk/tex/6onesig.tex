\section{Jednorázové a fail-stop podpisové schémy}

Jednorázové podpisové schémy, ako už ich názov napovedá, slúžia na
podpísanie práve jednej správy. Ich bezpečnosť je v prípade viacnásobného
podpisovania ohrozená. Načo sú nám teda takéto podpisové schémy? Zatiaľ to
vyzerá tak, že sú ia menej výhodné. Existujú však dôvody, prečo sa zaoberať
aj takýmito zjavne ``okrátenými'' podpisovými schémami.

Ich hlavná výhoda bude spočívať v jednoduchších predpokladoch pri dôkaze
bezpečnosti. Kým pri bežných podpisových schémach sme stavali na
tažkosti istých matematických problémov (RSA, dlog, Diffie-Hellman),
pri jednorázových schémach nám bude stačiť napríklad jednosmernosť
hashovacej funkcie.\footnote{Už aj toto je pomerne náročný predpoklad,
    keďže nevieme povedať veľa o existencii one-way funkcií}
Druhou výhodou môže byť rýchlosť - zrejme je jednoduchšie hashovať hodnoty
ako napríklad umocňovať.
Treťou výhodou (i keď skôr teoretickou) je možnosť odolať kvantovým
výpočtom - pre väčsinu používaných ťažkých problémov sú známe kvantové
algoritmy, ktoré ich efektívne počítajú. Pre invertovanie hashovacích
funkcií ale takéto algoritmy nie sú známe.

Otázka teda môže znieť, že či jednorázovosť je až taká obmedzujúca
vlastnosť. Môžeme napríklad uvažovať komunikáciu s bankou a podpisovanie
prevodných príkazov. Je jednoducho predstaviteľné, že povedzme za mesiac
bežný človek nespraví viac ako povedzme 5 príkazov. Preto môžeme použiť
niečo ako pohľad z opačnej strany - namiesto toho, aby sme navrhovali
podpisové schémy na polynomiálny počet podpísaných správ,
môžeme sa snažiť navrhnúť schémy na jednorázové podpisy a tie potom
rozšíriť nejakým spôsobom pre viac správ.

Jednorázovú podpisovou schému formálne definujeme veľmi podobne ako bežné
podpisové schémy

\begin{definicia}[Jednorázová podpisová schéma]
    je trojica algoritmov 
    $\langle Gen, Sign_{sk}, Verify_{pk} \rangle$ kde
    $Gen(1^k) \implies \langle pk, sk \rangle$ je generátor kľúčov,
    $Sign_{sk}(m) \implies \sigma$ je podpisovací algoritmus a
    $Verify_{pk}(m,\sigma) \implies \{0,1\}$ je overovací algoritmus.
\end{definicia}

Pojem bezpečnosti takejto schémy si upravíme na jednu správu.
\begin{definicia}[Bezpečnosť]
    Uvažujme útočníka ako PPT algoritmus, ktorý má navyše k dispozícii
    orákulum $Sig_{sk}$. Útočník sa môže raz opýtať orákula na podpis
    $\sigma$ správy $m$ a jeho cieľom je zostrojiť
    správu $m' \ne m$ a k nej platný podpis $\sigma'$.
    Budeme hovoriť, že schéma je bezpečná ak pravdepodobnosť,
    že ľubovoľný útočník uspeje (t.j. nájde $(m',\sigma')$), je zanedbateľná.
\end{definicia}

\subsection{Lamportova schéma}

Uvažujme, že máme funkciu $f: X \rightarrow Y$, ktorá je jednosmerná.
Budeme podpisovať správy $m$ fixnej veľkosti $|m|=n$. Toto samo o sebe nie
je žiadny problém, ak uvážime, že budeme podpisovať len hash správy, ktorý je
fixnej veľkosti.

Generovanie kľúča bude vyzerať nasledovne:
%%% {{{ proc GenLamport
\begin{procedure}
    \caption{GenLamport($n$)}
    \For{$i:=1$ \KwTo $n$}{
        $x_{i,0} \inr X$\;
        $x_{i,1} \inr X$\;
        $y_{i,0} \assign f(x_{i,0})$\;
        $y_{i,1} \assign f(x_{i,1})$\;
    }
    \Return $sk=(x_{1,0},x_{1,1},\ldots,x_{n,0},x_{n,1}),\quad
             pk=(y_{1,0},y_{1,1},\ldots,y_{n,0},y_{n,1})$\;
\end{procedure}
%%% }}}

Čitateľ už môže tušiť, ako budeme podpisovať správu - jednoducho postupne
podpíšeme všetyk jej bity tým, že zverejníme príslušnú časť súkromného
kľúča.

%%% {{{ SignLamport
\begin{procedure}
    \caption{SignLamport($m$)}
    \For{$i:=1$ \KwTo $n$}{
        $\sigma_i \assign f(x_{i, m_i})$\;
    }
    \Return $\sigma = (\sigma_1, \ldots, \sigma_n)$
\end{procedure}
%%% }}}

Overovanie spočíva v overení každého podpísaného bitu správy.

\begin{procedure}
    \caption{VerifyLamport($m, \sigma$)}
    \For{$i:=1$ \KwTo $n$}{
        \If{$f(x_{i, m_i}) \ne y_{i, m_i}$}{
            \Return reject\;
        }
    }
    \Return accept\;
\end{procedure}

Bezpečnosť schémy je založená na nasledujúcom pozorovaní:
Aby bol útočník k správe $m$ a jej podpisu $\sigma$ vygenerovať
falošnú správu $m' \ne m$ a jej podpis $\sigma'$, musel by byť schopný
vygenerovať $x_{i,b}$ pre nejakú novú dvojicu $(i,b)$.
To ale znamená invertovať niektorú hodnotu $y_{i,b}$ z verejnej
funkcie, predpokladáme, že je možné iba so zanedbateľnou
pravdepodobnosťou.

Na druhej strane, schéma je evidentne jednorázová.
Až na špeciálny prípad, keď sú podpísané dve správy $m_1,m_2$ líšiace
sa v práve jednom bite (vtedy si útočník nepomôže), vieme kombinovať
jednotlivé bity podpisov a podpísať inú správu. V prípade, že
podpisujeme hash hodnotu, je navyše očakávané, že správy sa budú líšiť
na zhruba polovici bitov.

Uvažujme teraz praktické aspekty používania takejto schémy. Podpisujme
hash, napríklad výstup z funkcie SHA-256. Ďalej predpokladajme, že
$|X|=|Y|=256 \unit{bit}$. Potom dostávame pre súkromný kľúč veľkosť
$|sk|=2*256*256 bit =16 \unit{kB}$. Verejný kľúč je rovnako dlhý, čiže
$|pk|=16 \unit{kB}$ a podpis má polovičnú dĺžku kľúčov - $|\sigma|=8
\unit{kB}$.
V porovnaní napríklad s RSA je to výrazne horšie. Bolo by teda dobré
nejakým spôsobom skrátiť kľúče.

Skrátenie súkromného kľúča: Namiesto celého kľúča $(x_{1,0}, x_{1,1},
\ldots x_{n,1})$ si budeme pamätať iba náhodné $x \inr X$ - seed pre
pseudonáhodý generátor, ktorý postupne vygeneruje dané hodnoty
$x_{i,b}$. Problém v tomto prípade je ďalší predpoklad - bezpečnost
pseudonáhodného generátora (t.j. že z niektorých hodnôt postupnosti
$x_{1,0}, \ldots, x_{n,1}$ nevieme efektívne vypočítať žiadnu ďalšiu -
to by bolo ekvivalentné zlomeniu podpisovej schémy).

Skrátenie verejného kľúča: Namiesto celého kľúča zverejníme iba hash
$y=H(y_{1,0},y_{1,1},\ldots,y_{n,1})$. Tým pádom ale pri podpisovaní
musíme uviesť aj všetky hodnoty $y$, aby si to overovateľ mohol
overiť. Po chvíli zamyslenia sa ale môžeme pozorovať, že na overenie
stačí poslať tie hodnoty $y_{i,b}$, ktoré si overovateľ nemôže
spočítať. Tieto sú presne negácie bitov správy a teda nám stačí poslať
iba polovicu hodnôt $y_{i,b}$. Podpis sa nám tým predĺži na $16
\unit{kB}$.

\subsubsection{Merkleho konštrukcia}
Ďalši nezávislú možnosť ako skrátiť dĺžku postupnosti vymyslel
Merkle. Hlavnou pointou bude pridať akúsi formu checksumu - počtu
nulových bitov správy. Potom budeme pri podpisovaní podpisovať iba
jednotkové bity, čím ušetríme v priemernom prípade takmer polovicu bitov
(čiže v našom prípade $|\sigma| \approx 4 \unit{kB}$).

Presnejšie, majme správu dĺžky $l$. K nej pridáme checksum dĺžky
$\lceil \log l \rceil$ a na výsledok dĺžky $n=l+\lceil \log l \rceil$
použijeme podpis, kde podpíšeme iba jednotkové bity.

V prvom rade by sme mali ukázať, že takáto zmena nepokazí bezpečnosť
schémy. Majme preto známu správu $m$ s podpisom $\sigma$ a
predpokladajme, že sa útočník snaží vyrobiť $m'$.
Ak existuje bit $i$, $m_i=0$ a platilo by $m'_i=1$, tak sa dostávame
do známej situácie, kedy útočník musí vyrobiť platný vzor pre $y_{i,1}$.
Ošemetná situácia ale nastáva, ak máme bit $m_i=1$ a útočník ho zmení
na nulu. V tomto prípade totiž nemusí nič podvrhnúť, lebo pre nulový
bit nemusí nič uviesť. Zachráni nás však checksum - totiž, ak zmenšíme
celkový počet jednotiek v správe (a to jediné nám ostáva, ak nemáme
nablyšťanú guľu na lámanie one-way funkcie), vznikne nám aspoň jedna
jednotka na doteraz neodhalenom mieste - nie je totiž možné, aby sme
po pričítaní čísla k checksume dostali checksumu pozostávajúci iba zo
známych bitov - to by znamenalo, že daná checksuma používa iba
niektoré jednotky z pôvodnej, lenže to je v spore s tým, že je
väčšia). Preto aj v tomto prípade musí útočník úspešne nájsť vzor
jednosmernej fukncie a schéma ostáva naďalej bezpečná.

Ďalšou príjemnou vlastnosťou tejto úpravy je automatické zmenšenie
súkromného a verejného kľúča na polovicu - vôbec nepotrebujeme
generovať $x_{i,0}$ a $y_{i,0}$.

\subsection{Merkleho stromy}
\subsection{Stanekova schéma}
\subsection{Fail/stop podpisové schémy}

Predstavme si, že chceme schému pri ktorej sme (ako podpisovateľ) chránený pred neobmedzene výpočtovo silným
falšovateľom. Inak povedané, žiadny útočník, nech je akokoľvek silný,
by nemal z prístupu k môjmu verejnému kľúču byť schopný generovať
platné podpisy. Toto je samozrejme mierne v rozpore s tým, že máme
vedieť overiť podpis. Preto budeme požadovať miernejšiu vec -
podpisovateľ bude schopný preukázať, že to nebolo podpísané jeho
súkromným kľúčom.
Opäť si predstavíme jednorázovú schému. Útočník v prípade získania
správy, jej podpisu a verejného kľúča nebude schopný identifikovať
jednoznačne súkromný kľúč (napríklad preto, že možných súkromných
kľúčov bude veľmi veľa)
a nebude schopný vyrobiť správny podpis inej správy.
Pokiaľ sa falšovateľ pokúsi podpisať inú správu, tak podpisovateľ zistí, že bol použitý iný
ako jeho súkromný kľúč a je to schopný preukázať.

\subsubsection{Heyst Pedersenova schéma}

Uvažujme grupu $G$, kde $|G| = q$ a $q$ je nejaké (dostatočne veľké) prvočíslo.
Zoberme generátory $g, h \in G$.
Súkromný kľúč bude štvorica  $sk = (x_1, x_2, y_1, y_2) \inr Z_q$.
Poznamenajme, že narozdiel od ElGamalovej schémy, hodnoty $x,y$ sú
náhodné a \emph{nezávislé}.
Verejný kľúč bude dvojica
$pk = (g^{x_1} h^{x_2}, g^{y_1} h^{y_2}) = (z_1, z_2)$, teda akýmsi
spôsobom previažeme obe hodnoty. Algoritmický zápis generovania je vo
funkcii \ref{funct:genhp}

\begin{function}[h!]
    \caption{GenHP($G$)}
    \label{funct:genhp}
    $g,h \assign $ rôzne generátory $G$\;
    $x_1,x_2,y_1,y_2 \inr G$\;
    $z_1 \assign g^{x_1} h^{x_2}$\;
    $z_2 \assign g^{y_1} h^{y_2}$\;
    \Return $sk=(g,h,x_1,x_2,y_1,y_2), pk=(g,h,z_1,z_2)$\;
\end{function}

Správu $m$ podpíšeme svojim súkromným kľúčom ako lineárnu kombináciu
$x_i, y_i, m$ pomocou funkcie \ref{funct:signhp}
\begin{function}[h!]
    \caption{SignHP($m$)}
    \label{funct:signhp}
    $\sigma_1 \assign x_1 + m y_1$\;
    $\sigma_2 \assign x_2 + m y_2$\;
    \Return $\sigma=(\sigma_1,\sigma_2)$\;
\end{function}

Overenie podpisu je jednoduché otestovanie
rovnosti:
\begin{function}[h!]
    \caption{VerifyHP($\sigma,m$)}
    \eIf{$g^{\sigma_1} h^{\sigma_2} == z_1 z_2^m$}{
        \Return accept\;
    }{
        \Return reject\;
    }
\end{function}

Teraz si dokážeme niekoľko vlastností tejto schémy.

\begin{lema}
Pre ľubovoľnú trojicu $pk, m, \sigma$, kde $\sigma = SigHP_{sk}(m)$
a $sk$ je nejaký vyhovujúci súkromný kľúč
existuje $q$ rôznych kľúčov $sk^*$, takých že $\sigma = Sig_{sk^*}(m)$.
\end{lema}

\begin{dokaz}
Nech $h = g^a$, $z_1 = g^{e_1}$ a $z_2 = g^{e_2}$ 
(neobmedzene silný útočník vie $a, e_1, e_2$ vypočítať).
Z toho, že $z_1 = g^{x_1} h^{x_2}$ máme rovnicu $e_1 = x_1 + ax_2$.
Podobne z $z_2 = g^{y_1} h^{y_2}$ dostaneme $e_2 = y_1 + a y_2$.
A ešte vďaka tomu, že $\sigma$ je podpis správy $m$ máme rovnice
$\sigma_1 = x_1 + my_1$, $\sigma_2 = x_2 + my_2$. 

Dostali sme 4 rovnice. Máme 4 neznáme. V maticovom tvare dostávame:
\begin{equation*}
    \left ( \begin{matrix}
                1 & a & 0 & 0 \cr 
                0 & 0 & 1 & a \cr
                1 & 0 & m & 0 \cr
                0 & 1 & 0 & m
            \end{matrix} \right )
    \left ( \begin{matrix}
                x_1 \cr x_2 \cr y_1 \cr y_2
            \end{matrix} \right )
    =
    \left ( \begin{matrix} 
                e_1 \cr e_2 \cr \sigma_1 \cr \sigma_2
            \end{matrix} \right )
\end{equation*}

Matica sústavy má ale hodnosť $3$. Jedno riešenie už máme (pôvodný
súkromný kľúč) a teda sústava má práve $q$ rôznych riešení (sme v
priestore $Z_q^4$).

\end{dokaz}

Toto dokazuje, že potenciálnych súkromných kľúčov je exponenciálne veľa.
Na to aby sme ukázali, že útočník má
šancu na úspech $\frac{1}{q}$ treba ešte ukázať jednu vec.
Môže totiž nastať patologický prípad, kde veľa súkromných kľúčov
pri podpise falošnej správy $m^*$ dá rovnaký podpis.
Teda budeme mať rôzne kľúče $sk^{'}, sk^{''}, \dots$, 
kde $Sig_{sk^{'}}(m^*) = Sig_{sk^{''}}(m^*) = \dots$.
To, že tento prípad nenastane ukazuje nasledujúca lema.

\begin{lema}
Pre ľubovoľné $pk, m, \sigma, m^*, \sigma^*$, kde $\sigma = Sig_{sk}(m)$, $\sigma^* = Sig_{sk}(m^*)$ a $sk$ vyhovuje $pk$
existuje maximálne jeden jediný vyhovujúci $sk$.
\end{lema}

\begin{dokaz}
Prvé 4 rovnice máme rovnaké ako v predchádzajúcej leme. Navyše dostaneme ešte rovnice $x_1 + m^*y_1 = \sigma_1^*$, 
$x_2 + m^* y_2 = \sigma_2^*$.
Pokiaľ zostrojíme maticu tejto sústavy bude mať hodnosť $4$ a teda bude mať maximálne jedno riešenie.
\end{dokaz}


Ešte treba vyriešiť otázku ako môže podpisujúci spochybniť podpis 
a či tomuto spochybneniu môžeme veriť.
Keďže je to jednorázová schéma, tak podpisujúci v prípade,
že chce spochybniť podpis, tak stačí ak zverejní vlastný súkromný kľúč.
V tom prípade vieme overiť, že nesedí s podpisom falošnej správy
a navyše vyhovuje verejnému kľúču.

Ukažeme ešte, že podpisujúci si nevie vymyslieť iný súkromný kľúč
(samozrejme ak je výpočtovo obmedzený). 
Nech jeho pôvodný súkromný kľúč je $sk = (x_1, x_2, y_1, y_2)$ a
chce si pripraviť nový kľúč $sk^{'} = (x_1^{'}, x_2^{'}, y_1^{'}, y_2^{'})$.
Potom platí $z_1 = g^{x_1} h^{y_1} = g^{x_1^{'}} h^{y_1^{'}}$ z čoho máme 
$h = g^{(x_1 - x_1^{'})(y_1^{'} - y_1)^{-1}}$.
A teda vieme zistiť $dlog_g h$.

%tuna redukciu na dlog stanek robil trochu inac (cez rovnost podpisov), toto sa mi zda byt priamejsie

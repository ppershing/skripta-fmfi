\section{Jednorázové a fail-stop podpisové schémy}

Jednorázové podpisové schémy, ako už ich názov napovedá, slúžia na
podpísanie práve jednej správy. Ich bezpečnosť je v prípade viacnásobného
podpisovania ohrozená. Načo sú nám teda takéto podpisové schémy? Zatiaľ to
vyzerá tak, že sú ia menej výhodné. Existujú však dôvody, prečo sa zaoberať
aj takýmito zjavne ``okrátenými'' podpisovými schémami.

Ich hlavná výhoda bude spočívať v jednoduchších predpokladoch pri dôkaze
bezpečnosti. Kým pri bežných podpisových schémach sme stavali na
tažkosti istých matematických problémov (RSA, dlog, Diffie-Hellman),
pri jednorázových schémach nám bude stačiť napríklad jednosmernosť
hashovacej funkcie.\footnote{Už aj toto je pomerne náročný predpoklad,
    keďže nevieme povedať veľa o existencii one-way funkcií}
Druhou výhodou môže byť rýchlosť - zrejme je jednoduchšie hashovať hodnoty
ako napríklad umocňovať.
Treťou výhodou (i keď skôr teoretickou) je možnosť odolať kvantovým
výpočtom - pre väčsinu používaných ťažkých problémov sú známe kvantové
algoritmy, ktoré ich efektívne počítajú. Pre invertovanie hashovacích
funkcií ale takéto algoritmy nie sú známe.

Otázka teda môže znieť, že či jednorázovosť je až taká obmedzujúca
vlastnosť. Môžeme napríklad uvažovať komunikáciu s bankou a podpisovanie
prevodných príkazov. Je jednoducho predstaviteľné, že povedzme za mesiac
bežný človek nespraví viac ako povedzme 5 príkazov. Preto môžeme použiť
niečo ako pohľad z opačnej strany - namiesto toho, aby sme navrhovali
podpisové schémy na polynomiálny počet podpísaných správ,
môžeme sa snažiť navrhnúť schémy na jednorázové podpisy a tie potom
rozšíriť nejakým spôsobom pre viac správ.

Jednorázovú podpisovou schému formálne definujeme veľmi podobne ako bežné
podpisové schémy

\begin{definicia}[Jednorázová podpisová schéma]
    je trojica algoritmov 
    $\langle Gen, Sign_{sk}, Verify_{pk} \rangle$ kde
    $Gen(1^k) \implies \langle pk, sk \rangle$ je generátor kľúčov,
    $Sign_{sk}(m) \implies \sigma$ je podpisovací algoritmus a
    $Verify_{pk}(m,\sigma) \implies \{0,1\}$ je overovací algoritmus.
\end{definicia}

Pojem bezpečnosti takejto schémy si upravíme na jednu správu.
\begin{definicia}[Bezpečnosť]
    Uvažujme útočníka ako PPT algoritmus, ktorý má navyše k dispozícii
    orákulum $Sig_{sk}$. Útočník sa môže raz opýtať orákula na podpis
    $\sigma$ správy $m$ a jeho cieľom je zostrojiť
    správu $m' \ne m$ a k nej platný podpis $\sigma'$.
    Budeme hovoriť, že schéma je bezpečná ak pravdepodobnosť,
    že ľubovoľný útočník uspeje (t.j. nájde $(m',\sigma')$), je zanedbateľná.
\end{definicia}

\subsection{Lamportova schéma}

Uvažujme, že máme funkciu $f: X \rightarrow Y$, ktorá je jednosmerná.
Budeme podpisovať správy $m$ fixnej veľkosti $|m|=n$. Toto samo o sebe nie
je žiadny problém, ak uvážime, že budeme podpisovať len hash správy, ktorý je
fixnej veľkosti.

Generovanie kľúča bude vyzerať nasledovne:
%%% {{{ proc GenLamport
\begin{procedure}
    \caption{GenLamport($n$)}
    \For{$i:=1$ \KwTo $n$}{
        $x_{i,0} \inr X$\;
        $x_{i,1} \inr X$\;
        $y_{i,0} \assign f(x_{i,0})$\;
        $y_{i,1} \assign f(x_{i,1})$\;
    }
    \Return $sk=(x_{1,0},x_{1,1},\ldots,x_{n,0},x_{n,1}),\quad
             pk=(y_{1,0},y_{1,1},\ldots,y_{n,0},y_{n,1})$\;
\end{procedure}
%%% }}}

Čitateľ už môže tušiť, ako budeme podpisovať správu - jednoducho postupne
podpíšeme všetyk jej bity tým, že zverejníme príslušnú časť súkromného
kľúča.

%%% {{{ SignLamport
\begin{procedure}
    \caption{SignLamport($m$)}
    \For{$i:=1$ \KwTo $n$}{
        $\sigma_i \assign f(x_{i, m_i})$\;
    }
    \Return $\sigma = (\sigma_1, \ldots, \sigma_n)$
\end{procedure}
%%% }}}

Overovanie spočíva v overení každého podpísaného bitu správy.

\begin{procedure}
    \caption{VerifyLamport($m, \sigma$)}
    \For{$i:=1$ \KwTo $n$}{
        \If{$f(x_{i, m_i}) \ne y_{i, m_i}$}{
            \Return reject\;
        }
    }
    \Return accept\;
\end{procedure}

Bezpečnosť schémy je založená na nasledujúcom pozorovaní:


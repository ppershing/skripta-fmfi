\section{Inkrementálne hašovanie}

\subsubsection{Motivácia}

Predstavme si, že máme dlhý dokument (súbor, disk),
označme ho $m$ a chceme si uchovávať jeho hash. Pri klasickom riešení
by sme museli prejsť celý dokument a spočítať jeho 
hash $H(m)$. Následne keď urobíme čo i len najmenšiu
zmenu, tak na to, aby sme získali novú hash musíme opäť
prejsť celý súbor. Toto je náročné na systémové prostriedky.

\subsection{Triviálne riešenia}

Môžeme náš dokument rozdeliť na časti (disk na sektory)
a uchovávať hash každej časti osobitne. V prípade, keď
$m = m_1 m_2 \dots m_k$, tak hash bude 
$H(m) = <h(m_1), h(m_2), \dots, h(m_k)>$.
Toto riešenie má ale oveľa dlhšiu hash.

Iné riešenie je použiť Merkleho stromy. Tak si ale preto, aby
sme mali rýchly update hashe musíme pamätať zloženie celého stromu, čo tiež nie je potešujúce.


\subsection{Lepšie riešenia}

Zoberme konečnú komutatívnu grupu $(G, \odot)$ (napr. $(2^n, XOR)$).
Následne predpokladajme, že máme hašovaciu funkciu s oborom hodnôť $G$.
Rozdeľme dokument na $k$ blokov $m = x_1 x_2 \dots x_k$ Naša hash bude 
$H(m) = \displaystyle\bigodot_{j=1}^k h(i, x_i)$. 
Pokiaľ sa blok $x_i$ zmení na $x_i^{'}$, tak nová hash bude:
$$H(m^{'}) = H(m) \odot h(i, x_i)^{-1} \odot h(i, x_i^{'})$$

\subsubsection{Súvislosť s problémom vyvažovania}

Dá sa ukázať, že nájsť kolíziu pre incrementálnu hašovaciu
funkciu používajúcu grupu $G$ je aspoň tak ťažké ako riešiť
problém vyvažovania (ktorého obťiažnosť závisí hlavne od grupy 
$G$).

\begin{definicia}
Máme zadanú grupu $(G, \odot)$ a postupnosť $a_1, a_2, \dots, a_n$. Našou úlohou
je nájsť čísla $w_1, w_2, \dots, w_n \in \{-1, 0, 1\}$, kde aspoň jedno z nich
je nenulové a platí $a_1^{w_1} \odot a_2^{w_2} \odot \dots \odot a_n^{w_n}$.
Tomuto problému hovoríme problém vyvažovania.
\end{definicia}

\begin{poznamka}
Pokiaľ je grupa $G$ komutatívna, tak vlastne hľadáme dve neprázdne disjuktné podmnožiny
$I, J \subseteq \{1, 2, \dots, n\}$, kde platí $\bigodot_{i\in I} a_i = \bigodot_{j \in J} a_j$.
\end{poznamka}

\begin{lema}
Ak vieme v grupe $(G, \odot)$ hľadať kolízie pre inkrementálne hašovacie
funkcie, tak vieme rovnako efektívne riešiť problém vyvažovania.
\end{lema}

\begin{dokaz}
Majme orákulum $A$, ktoré hľadá kolíziu pre inkrementálnu hašovaciu
funkciu nad grupou $(G, \odot)$. Toto orákulum nám položí $q$ otázok
typu aká je hodnota $h(i, x_i)$. Na tieto otázky mu odpovieme postupne $a_1, a_2, \dots, a_q$.
Orákulum podá odpoveď $H(x) = H(y)$, čo je vlastne $\bigodot_{i \in I} a_i = \bigodot_{j \in J} a_j$.
(Keďže predpokladáme, že funkcia $h$ sa správa ako náhodné orákulum, tak sa na všetky zložky
$x$ a $y$ musí $A$ opýtať.)
\end{dokaz}

\subsection{XOR-hash}

Najprv si ukážeme tzv. XOR-HASH.
Predpokladajme, že $h\colon \{0,1\}^l \to \{0,1\}^n$.
Hash bude daná vzorcom:
$H(m) = \displaystyle\bigoplus_{j=1}^k h(i, x_i)$.

Ukážeme, že aj v prípade, že $h$ je kvalitná hašovacia funkcia
(správa sa ako náhodné orákulum) vieme XOR-HASH invertovať.

Na vstupe majme $z \in \{0,1\}^n$. Najprv si pripravíme
2 náhodné dokumenty $x^0 = x_1^0 x_2^0 \dots x_k^0$ a 
$x_1 = x_1^1 x_2^1 \dots x_k^1$. Spočítame si hashe ich častí:
$a_i^b = h(i, x_i^b)$. 
Teraz chceme nájsť $y = y_1 y_2 \dots y_k$, kde $y_1 \in \{0,1\}$,
také, že $z = a_1^{y_1} \oplus a_2^{y_2} \oplus \dots \oplus a_k^{y_k}$
(teda $H(x_1^{y_1} x_2^{y_2} \dots x_k^{y_k}) = z$).
Táto rovnica sa dá napísať aj ako:
$$z = a_1^0 (1 - y_1) \oplus a_1^1 y_1 \oplus \dots \oplus a_k^0 (1 - y_k) \oplus a_k^1 y_k$$

Keďže $z$ má $n$ bitov a všetky tieto bity sa počítajú nezávisle od ostatných vieme
zostaviť $n$ rovníc nad $Z_2$. A máme $k$ neznámych. Keďže v praktických
aplikáciách je $k > n$ dostaneme skoro vždy riešenie.

\todo{sanca na najdenie riesenia}

\subsection{Ad-hash}

Tento krát spravíme iteratívnu hash v grupe $(Z_m, +)$.
Tu sa dá ukázať, že problém vyvažovania pre $(Z_m, +)$
je ťažký. 

V praxi sa používajú napr. tieto 2 konštrukcie:

NASD konštrukcia:
$$H(x) = \displaystyle\sum_{i=1}^k h(i, x_i) \bmod 2^{256}$$

DCIHF konštrukcia:
$$H(x) = \displaystyle\sum_{i=1}^{k-1} \textrm{SHA-1}(x_i, x_{i+1}) \bmod 2^{160}+1$$

\subsection{Zovšeobecnený narodeninový útok}

Predstavme si, že máme dva zoznamy slov $L_1, L_2 \in \{0,1\}^n$ vygenerované
napríklad pomocou hašovacej funkcie. Teraz chceme nájsť
$x_1 \in L_1, x_2 \in L_2\colon x_1 = x_2 \Leftrightarrow x_1 \oplus x_2 = 0$.

Toto je starý známy narodeninový útok. Pokiaľ obidva zoznamy budú mať veľkosť
$2^{n/2}$, tak máme celkom dobrú šancu, že takáto dvojica existuje. Nájdeme ju
už ľahko - jeden zoznam vložíme do hašovacej tabuľký a skúšame potom v tejto
tabuľke hľadať prvky z druhého zoznamu.
Celkový čas útoku by bol $O(2^{n/2})$.

Tento druh útoku môžeme zovšeobecniť pre $k$ zoznamov $L_1, L_2, \dots, L_k$.
Potom naša požiadavka na vybrané slová je: $x_1 \oplus x_2 \oplus \dots \oplus x_k = 0$.

Ukážeme si ako vieme jednoducho hľadať takéto slová pre $k=4$.

Vygenerujeme zoznamy $L_1, L_2, L_3, L_4$ z veľkosťou $2^{n/4}$. 
Následne vyrobíme všetky kombinácie $x_1 \oplus x_2$ a $x_3 \oplus x_4$, kde
$x_1 \in L_1, x_2 \in L_2, x_3 \in L_3, x_4 \in L_4$.
Každej z týchto kombinácií bude $2^{n/2}$. Následne prevedieme útok pre $k=2$.
Takže celkový čas opäť bude $O(2^{n/2})$.

Zatiaľ sme si ale veľmi nepomohli. Ale v roku 2002 Wagner \cite{birthday}
našiel rýchlejší útok.

Najprv si ale zadefinujme operáciu spojenia (join). Nech $low_l(x)$ predstavuje
posledných $l$ bitov slova $x$. Potom:
$L \bowtie_l L^{'} = \{(x, x^{'}) | x \in L \land x^{'} \in L^{'} \land low_{l}(x) = low_l(x^{'})\}$
Teda vyberieme z $L$ a $L^{'}$ tie dvojice slov, ktoré sa zhodujú na posledných
$l$ bitoch.

Teraz si ukážeme útok pre $4$ zoznamy. 
\begin{enumerate}
\item Pripravíme si zoznamy veľkosti $2^{n/3}$.
\item Vypočítame $L_{12} = L_1 \bowtie_{n/3} L_2$.
\item Vypočítame $L_{34} = L_3 \bowtie_{n/3} L_4$.
\item Vypočítame $L_{12} \bowtie L_{34}$.
\end{enumerate}

Pozrime sa na časovú zložitosť. Očakávaná veľkosť $L_{12}$ bude $2^{n/3} \cdot 2^{n/3} / 2^{n/3} = 2^{n/3}$ (zoberieme všetky možné
dvojice a požadujeme rovnosť posledných $n/3$ bitov). V tomto istom čase vieme aj vygenerovať tento zoznam. To isté
dostaneme aj pre $L_{34}$. Očakávaná veľkosť výstupu z posledného kroku je $2^{n/3} \cdot 2^{n/3} / 2^{2n/3} = 1$.
Časová zložitosť opať bude $O(2^{n/3})$.

\todo{zovseobecneny birthday attack}


\section{Inkrementálne hašovanie}

\subsubsection{Motivácia}

Predstavme si, že máme dlhý dokument (súbor, disk),
označme ho $m$ a chceme si uchovávať jeho hash. Pri klasickom riešení
by sme museli prejsť celý dokument a spočítať jeho 
hash $H(m)$. Následne keď urobíme čo i len najmenšiu
zmenu, tak na to, aby sme získali novú hash musíme opäť
prejsť celý súbor. Toto je náročné na systémové prostriedky.

\subsection{Triviálne riešenia}

Môžeme náš dokument rozdeliť na časti (disk na sektory)
a uchovávať hash každej časti osobitne. V prípade, keď
$m = m_1 m_2 \dots m_k$, tak hash bude 
$H(m) = <h(m_1), h(m_2), \dots, h(m_k)>$.
Toto riešenie má ale oveľa dlhšiu hash.

Iné riešenie je použiť Merkleho stromy. Tak si ale preto, aby
sme mali rýchly update hashe musíme pamätať zloženie celého stromu, čo tiež nie je potešujúce.


\subsection{Lepšie riešenia}

Zoberme konečnú komutatívnu grupu $(G, \odot)$ (napr. $(2^n, XOR)$).
Následne predpokladajme, že máme hašovaciu funkciu s oborom hodnôť $G$.
Rozdeľme dokument na $k$ blokov $m = x_1 x_2 \dots x_k$ Naša hash bude 
$H(m) = \displaystyle\bigodot_{j=1}^k h(i, x_i)$. 
Pokiaľ sa blok $x_i$ zmení na $x_i^{'}$, tak nová hash bude:
$$H(m^{'}) = H(m) \odot h(i, x_i)^{-1} \odot h(i, x_i^{'})$$

\subsubsection{Súvislosť s problémom vyvažovania}

Dá sa ukázať, že nájsť kolíziu pre incrementálnu hašovaciu
funkciu používajúcu grupu $G$ je aspoň tak ťažké ako riešiť
problém vyvažovania (ktorého obťiažnosť závisí hlavne od grupy 
$G$).

\begin{definicia}
Máme zadanú grupu $(G, \odot)$ a postupnosť $a_1, a_2, \dots, a_n$. Našou úlohou
je nájsť čísla $w_1, w_2, \dots, w_n \in \{-1, 0, 1\}$, kde aspoň jedno z nich
je nenulové a platí $a_1^{w_1} \odot a_2^{w_2} \odot \dots \odot a_n^{w_n}$.
Tomuto problému hovoríme problém vyvažovania.
\end{definicia}

\begin{poznamka}
Pokiaľ je grupa $G$ komutatívna, tak vlastne hľadáme dve neprázdne disjuktné podmnožiny
$I, J \subseteq \{1, 2, \dots, n\}$, kde platí $\bigodot_{i\in I} a_i = \bigodot_{j \in J} a_j$.
\end{poznamka}

\begin{lema}
Ak vieme v grupe $(G, \odot)$ hľadať kolízie pre inkrementálne hašovacie
funkcie, tak vieme rovnako efektívne riešiť problém vyvažovania.
\end{lema}

\begin{dokaz}
Majme orákulum $A$, ktoré hľadá kolíziu pre inkrementálnu hašovaciu
funkciu nad grupou $(G, \odot)$. Toto orákulum nám položí $q$ otázok
typu aká je hodnota $h(i, x_i)$. Na tieto otázky mu odpovieme postupne $a_1, a_2, \dots, a_q$.
Orákulum podá odpoveď $H(x) = H(y)$, čo je vlastne $\bigodot_{i \in I} a_i = \bigodot_{j \in J} a_j$.
(Keďže predpokladáme, že funkcia $h$ sa správa ako náhodné orákulum, tak sa na všetky zložky
$x$ a $y$ musí $A$ opýtať.)
\end{dokaz}

\subsection{XOR-hash}

Najprv si ukážeme tzv. XOR-HASH.
Predpokladajme, že $h\colon \{0,1\}^l \to \{0,1\}^n$.
Hash bude daná vzorcom:
$H(m) = \displaystyle\bigoplus_{j=1}^k h(i, x_i)$.

Ukážeme, že aj v prípade, že $h$ je kvalitná hašovacia funkcia
(správa sa ako náhodné orákulum) vieme XOR-HASH invertovať.

Na vstupe majme $z \in \{0,1\}^n$. Najprv si pripravíme
2 náhodné dokumenty $x^0 = x_1^0 x_2^0 \dots x_k^0$ a 
$x_1 = x_1^1 x_2^1 \dots x_k^1$. Spočítame si hashe ich častí:
$a_i^b = h(i, x_i^b)$. 
Teraz chceme nájsť $y = y_1 y_2 \dots y_k$, kde $y_1 \in \{0,1\}$,
také, že $z = a_1^{y_1} \oplus a_2^{y_2} \oplus \dots \oplus a_k^{y_k}$
(teda $H(x_1^{y_1} x_2^{y_2} \dots x_k^{y_k}) = z$).
Táto rovnica sa dá napísať aj ako:
$$z = a_1^0 (1 - y_1) \oplus a_1^1 y_1 \oplus \dots \oplus a_k^0 (1 - y_k) \oplus a_k^1 y_k$$

Keďže $z$ má $n$ bitov a všetky tieto bity sa počítajú nezávisle od ostatných vieme
zostaviť $n$ rovníc nad $Z_2$. A máme $k$ neznámych. Keďže v praktických
aplikáciách je $k > n$ dostaneme skoro vždy riešenie.

\todo{sanca na najdenie riesenia}

\subsection{Ad-hash}

Tento krát spravíme iteratívnu hash v grupe $(Z_m, +)$.
Tu sa dá ukázať, že problém vyvažovania pre $(Z_m, +)$
je ťažký. 

V praxi sa používajú napr. tieto 2 konštrukcie:

NASD konštrukcia:
$$H(x) = \displaystyle\sum_{i=1}^k h(i, x_i) \bmod 2^{256}$$

DCIHF konštrukcia:
$$H(x) = \displaystyle\sum_{i=1}^{k-1} \textrm{SHA-1}(x_i, x_{i+1}) \bmod 2^{160}+1$$

\todo{zovseobecneny birthday attack}

